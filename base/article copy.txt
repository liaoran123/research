package rse

import (
	"fmt"

	"research/gstr"
	"research/pubgo"
	"strconv"
	"strings"

	"github.com/syndtr/goleveldb/leveldb/util"
)

//搜索系统文章的添加、修改、删除
/*
leveldb

ml- 目录表
.k=ml-tid;v=文章标题-url
***********************************
s- 内容表
s-文章id-分段id；v=分段内容
."文章id-分段id",组成唯一id
--------
i- 内容索引表
.k=i-长度7的分段内容遍历分词-文章id-分段id;v=空值
.i-最后后面加内容表的唯一id："文章id-分段id"，为了相同分词之后按内容表先后排序一致
*/
type Article struct {
	Tid        int //文章id，仅添加时用到
	keywordlen int //索引长度
	Con        *Connect
	Ainc       *Autoinc
	//mu         sync.RWMutex
	succ bool //记录事务流程的成功状态。
}

//
func NewArticle(keywordlen, count int) *Article {
	return &Article{
		//Tid: id,                //文章id
		Con: NewConnect(count), //count分库个数
	}
}

//获取下一个自动增值的id
func (a *Article) GetAutoincId() {
	bid := Art.Con.Fulltext.Getbyte("artlastid")
	if string(bid) == "" {
		bid = []byte("1") //默认起始值必须是1.当fid=0时，表示没有fid，则不需要进行fid索引。
	}
	a.Ainc.Id = pubgo.BytesToInt(bid)
}

//设置记录下一个自动增值的id
//leveldb是单线程写数据，故SetAutoincId需要在最后执行，以能保证事务完整性
func (a *Article) SetAutoincId(id int) {
	if !a.succ { //保证数据库完整性的事务处理
		return //支持简单的回滚。
	}
	a.Ainc.Inc()
	err = a.Con.Fulltext.Db.Put([]byte("artlastid"), pubgo.IntToBytes(a.Ainc.Id), nil)
	a.chekerr()
}

////将当前的自增值id赋给当前要添加的对象。
func (a *Article) SetTId() {
	//a.mu.Lock()
	a.Tid = a.Ainc.Id
	//a.Ainc.Inc()      //递增
	//a.SetAutoincId(a.Ainc.Id) //写入记录
	//a.mu.Unlock()
}

//添加目录标题，url，网址或文件地址
func (a *Article) AddCatalog(title, url string) {
	err = a.Con.Fulltext.Db.Put(pubgo.JoinBytes([]byte("ml-"), pubgo.IntToBytes(a.Tid)), []byte(title+"-"+url), nil) //添加目录标题
	a.chekerr()
}

/*
func (a *Article) AddCatalog(title string, fid int) {
	err = a.Con.Fulltext.Db.Put(pubgo.JoinBytes([]byte("ml-"), pubgo.IntToBytes(a.Tid)), []byte(title), nil) //添加目录标题
	a.chekerr()

		//fid索引//该功能留定制开发
			if fid == 0 { //不设置fid
				return
			}
			err = a.Con.Fulltext.Db.Put(pubgo.JoinBytes([]byte("f-"), pubgo.IntToBytes(fid), []byte("-"), pubgo.IntToBytes(a.Tid)), []byte{}, nil) //添加目录标题
			a.chekerr()

}*/

//添加内容，将文章分成多个句子段落后添加到表
func (a *Article) Addtext(text, split string) {
	itext := text //title+"\n"+text
	if split != "" {
		//支持多个分段匹配标签。中文常见是“。”.
		//空格是组合查询，由于支持英文，故而空格不作默认分隔符
		ss := strings.Split(split, ",")
		for _, v := range ss {
			itext = strings.Replace(itext, v, v+"\n", -1) //分配段落
		}
	}
	section := strings.Split(itext, "\n")
	i := 0
	s := ""
	for _, sec := range section {
		s = strings.TrimSpace(sec)
		if s == "" {
			continue
		}
		err = a.Con.Fulltext.Db.Put(pubgo.JoinBytes([]byte("s-"), pubgo.IntToBytes(a.Tid), []byte("-"), pubgo.IntToBytes(i)), []byte(s), nil)
		i++
		a.chekerr()
	}
}

//添加内容索引.pfx=表名
func (a *Article) AddIdx(pfx string) {
	iter := a.Con.Fulltext.Db.NewIterator(util.BytesPrefix([]byte(pfx+strconv.Itoa(a.Tid))), nil)
	var key string
	var disparte []string
	var pk, pv []byte
	for iter.Next() {
		key = string(iter.Key())
		disparte = a.ForDisparte(string(iter.Value()))
		for _, dv := range disparte {
			pk = pubgo.JoinBytes([]byte("i-"), []byte(dv), []byte("-"), []byte(gstr.RStr(key, "-")))
			pv = []byte{}
			err = a.Con.Getdb(dv).Db.Put(pk, pv, nil)
			fmt.Println(string(pk), string(pv))
			a.chekerr()
		}
	}
	iter.Release()
	err = iter.Error()
	a.chekerr()
}

/*
func (a *Article) AddIdx(pfx string) {
	iter := a.Con.Fulltext.Db.NewIterator(util.BytesPrefix([]byte(pfx+strconv.Itoa(a.Tid))), nil)
	var key string
	var nr, knr string //, fid
	var ml, cl int

	var pk, pv []byte
	var r, idxstr []rune

	for iter.Next() {
		key = string(iter.Key())
		nr = string(iter.Value())
		r = []rune(nr)
		cl = len([]rune(nr))
		for cl > 0 {
			if cl >= a.keywordlen {
				ml = a.keywordlen
			} else {
				ml = cl
			}
			idxstr = r[:ml]
			knr = string(idxstr)
			pk = pubgo.JoinBytes([]byte("i-"), []byte(knr), []byte("-"), []byte(gstr.RStr(key, "-")))
			pv = []byte{}
			err = a.Con.Getdb(nr).Db.Put(pk, pv, nil)
			fmt.Println(string(pk), string(pv))
			a.chekerr()
			r = r[1:]
			cl = len(r)
		}
	}
	iter.Release()
	err = iter.Error()
	a.chekerr()
}
*/
//遍历分词
func (a *Article) ForDisparte(nr string) (disparte []string) {
	var knr string //, fid
	var ml, cl int
	var r, idxstr []rune
	r = []rune(nr)
	cl = len([]rune(nr))
	for cl > 0 {
		if cl >= a.keywordlen {
			ml = a.keywordlen
		} else {
			ml = cl
		}
		idxstr = r[:ml]
		knr = string(idxstr)
		disparte = append(disparte, knr)
		r = r[1:]
		cl = len(r)
	}
	return
}

//添加标题的索引
//该功能摒弃，在内容也可以搜索到。
//有此特殊需求可定制开发.
/*
func (a *Article) AddtitleIdx(nr string) {
	var knr string //, fid
	var ml, cl int
	var r, idxstr []rune
	var pk, pv []byte
	r = []rune(nr)
	cl = len(r)
	for cl > 0 {
		if cl >= a.keywordlen {
			ml = a.keywordlen
		} else {
			ml = cl
		}
		idxstr = r[:ml]
		knr = string(idxstr)
		pk = pubgo.JoinBytes([]byte("t-"), []byte(knr))
		pv = pubgo.IntToBytes(a.Tid) //[]byte(a.Tid11)
		err = a.Con.Fulltext.Db.Put(pk, pv, nil)
		fmt.Println(string(pk), string(pv))
		a.chekerr()
		r = r[1:]
		cl = len(r)
	}

}
*/
func (a *Article) chekerr() {
	a.succ = a.succ && err == nil //记录事务流程成功状态
	if !a.succ {
		fmt.Println(err)
	}
}

//files.saveConflictResolution

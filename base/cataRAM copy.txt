package base

import (
	"strings"
)

var CataRAMMap = map[uint32]uint32{} //为了减少gc而设
var CRAMs *CataRAMs

//目录数据少，使用频繁，故适宜加载入内存
//删除目录时不能真正删除，只需将除id外置空即可。这样保证通过id直接匹配数组下标。
type cataRAM struct {
	id, fid int
	name    string
}

func NewcataRAM(id, fid int, name string) *cataRAM {
	return &cataRAM{
		id:   id,
		fid:  fid,
		name: name,
	}
}

type CataRAMs struct {
	cataRAM []*cataRAM
}

func NewCataRAMs() *CataRAMs {
	return &CataRAMs{}
}
func (c *CataRAMs) LoadCataRAM() {
	Con.Getartdb().FindRangeFun("ca-", "ca-a", c.toRAM)
}
func (c *CataRAMs) toRAM(k, v []byte) {
	key := strings.Split(string(k), "-")
	id := BytesToInt([]byte(key[1]))
	value := strings.Split(string(v), "-")
	var fid int
	var name string
	if value[2] == "" {
		fid = BytesToInt([]byte(value[1]))
		name = value[0]
	} else { //已经删除的目录
		fid = 0
		name = ""
	}

	c.cataRAM = append(c.cataRAM, NewcataRAM(id, fid, name))
}
func (c *CataRAMs) append(id, fid int, name string) {
	if len(CRAMs.cataRAM) < id {
		CRAMs.cataRAM = append(CRAMs.cataRAM, NewcataRAM(id, fid, name))
	} else {
		CRAMs.cataRAM[id-1].fid = fid
		CRAMs.cataRAM[id-1].name = name
	}
}

//并不是真正删除。否则目录表id和数组下标不能对应。
func (c *CataRAMs) Del(id int) {
	c.cataRAM[id].fid = 0
	c.cataRAM[id].name = ""
}

//修改。
func (c *CataRAMs) Put(id, fid int, name string) {
	c.cataRAM[id].fid = fid
	c.cataRAM[id].name = name
}

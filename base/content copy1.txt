package base

/*
i- 内容索引表
.k=i-长度7的分段内容遍历分词-文章id-分段id;v=空值
.i-最后后面加内容表的唯一id："文章id-分段id"，为了相同分词之后按内容表先后排序一致
*/
import (
	"fmt"
	"strings"
)

//内容表
type content struct {
	tbn string
	idx *idx
}

func Newcontent() *content {
	return &content{
		tbn: "c",
		idx: Newidx(),
	}
}

//***********添加*******************
//添加内容，将文章分成多个句子段落后添加到表
func (c *content) TextSplit(text, split string) (section []string) {
	itext := text //title+"\n"+text
	if split != "" {
		//支持多个分段匹配标签。中文常见是“。”.
		//空格是组合查询，由于支持英文，故而空格不作默认分隔符
		ss := strings.Split(split, "|")
		for _, v := range ss {
			itext = strings.Replace(itext, v, v+"\n", -1) //分配段落
		}
	}
	section = strings.Split(itext, "\n")
	return
}

//添加内容，将文章分成多个句子段落后添加到表
func (c *content) Insert(id int, section []string) (r bool) {
	i := 0
	s := ""
	r = true
	for _, sec := range section {
		s = strings.TrimSpace(sec)
		if s == "" {
			continue
		}
		if r { //添加内容
			err = Con.Getartdb().Db.Put(JoinBytes([]byte(c.tbn+"-"), IntToBytes(id), []byte("-"), IntToBytes(i)), []byte(s), nil)
		} else {
			return
		}
		r = r && err == nil
		r = r && c.idx.Insert(id, i, sec) //添加内容索引
		i++
		Chekerr()
	}
	return
}

//******搜索*************************************
//idx.Search(...)该函数不能放进idx结构类。
//为了优化组合查询速度，搜索时会使用到content类。
//这样造成循环引用。故提出到该层来实现。
func (c *content) Search(keyword, p, rand string, order bool, count int) (ids []Ids, lastkey string) {
	ks := strings.Split(keyword, " ")
	//获取字数最长的词，通常字数最长的就是数据量最少的词。以该词作为组合查询的遍历定位词。
	kw := c.getMaxLenKw(ks)
	kw = Sublen(kw, c.idx.keywordlen) //搜索词最大长度

	if len(strings.Split(p, "-")) == 1 { //p不是页码，而是页码的起始key
		p = c.getfirst(kw, order) //第一次搜索没有初始定位key，需要获取
	}
	iter := c.idx.Getniliter(kw) // Con.Getidxdb(kw).Db.NewIterator(nil, nil)
	ok := iter.Seek([]byte(p))
	if !ok {
		return
	}
	//测试代码begin
	iter.Next()
	fmt.Println(string(iter.Key()), string(iter.Value()))
	iter.Next()
	fmt.Println(string(iter.Key()), string(iter.Value()))
	iter.Next()
	fmt.Println(string(iter.Key()), string(iter.Value()))
	iter.First()
	fmt.Println(string(iter.Key()), string(iter.Value()))
	iter.Last()
	fmt.Println(string(iter.Key()), string(iter.Value()))
	//测试代码end
	ok = fixed[order](iter)
	succ := 0
	var e bool
	var key string
	var artid, secid int
	for ok {
		e = true
		key = string(iter.Key())
		if !strings.Contains(key, kw) { //已经不在范围内。
			break
		}
		artid, secid = c.getids(key)
		e = e && c.exsit(artid, secid, ks)
		if !e {
			continue
		}
		ids = append(ids, newIds(artid, secid))
		succ++
		if succ >= count {
			lastkey = key
			break
		}
		ok = move[order](iter)
	}
	iter.Release()
	err = iter.Error()
	Chekerr()
	lastkey = key
	return
}
func (c *content) exsit(artid, secid int, ks []string) (find bool) {
	find = true
	var sec []byte
	sec, err = Con.Getartdb().Db.Get(JoinBytes([]byte(c.tbn+"-"), IntToBytes(artid), IntToBytes(secid)), nil)
	Chekerr()
	secstr := string(sec)
	for _, v := range ks {
		find = find && strings.Contains(secstr, v)
	}
	return
}

//找出最大长度的词
func (c *content) getMaxLenKw(ks []string) (s string) {
	l := 0
	lv := 0
	for _, v := range ks {
		lv = len([]rune(v))
		if lv > l {
			s = v
			l = lv
		}
	}
	return
}

//提取文章，段落id
func (c *content) getids(key string) (artid, secid int) {
	para := strings.Split(key, "-")
	artid = BytesToInt([]byte(para[2])) //文章id
	secid = BytesToInt([]byte(para[3])) //段落id
	return
}

//用于第一次搜索时初始化开始key
func (c *content) getfirst(pfx string, order bool) (inikey string) {
	iter := c.idx.Getiter(pfx)
	if fixed[order](iter) {
		inikey = string(iter.Key())
	}
	return
}

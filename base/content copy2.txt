package base

/*
i- 内容索引表
.k=i-长度7的分段内容遍历分词-文章id-分段id;v=空值
.i-最后后面加内容表的唯一id："文章id-分段id"，为了相同分词之后按内容表先后排序一致
*/
import (
	"strconv"
	"strings"

	"github.com/syndtr/goleveldb/leveldb/util"
)

//内容表
type content struct {
	tbn  string
	idx  *idx
	fidx *fididx
}

func Newcontent() *content {
	return &content{
		tbn:  "c",
		idx:  Newidx(),
		fidx: Newfididx(),
	}
}

//***********添加*******************
//添加内容，将文章分成多个句子段落后添加到表
func (c *content) TextSplit(text, split string) (section []string) {
	itext := text //title+"\n"+text
	if split != "" {
		//支持多个分段匹配标签。中文常见是“。”.
		//空格是组合查询，由于支持英文，故而空格不作默认分隔符
		ss := strings.Split(split, "|")
		for _, v := range ss {
			itext = strings.Replace(itext, v, v+"\n", -1) //分配段落
		}
	}
	section = strings.Split(itext, "\n")
	return
}

//添加内容
func (c *content) Insert(id, fid int, title, text, split, url string) (r bool) {
	r = c.InsertFid(id, fid)
	r = r && c.InsertConAndIdx(id, title, text, split, url)
	return
}

//添加文章对应的fid，即所属目录
func (c *content) InsertFid(artid, fid int) (r bool) {
	if fid != 0 { //0，是顶级目录
		r = c.fidx.Insert(artid, fid)
	}
	Chekerr()
	return
}

//添加内容和索引，将文章分成多个句子段落后添加到表和索引
func (c *content) InsertConAndIdx(id int, title, text, split, url string) (r bool) {
	i := 0
	s := ""
	/*
		《"+title+"》\n 将标题加入内容，即不需要多加一个标题的搜索。通过“《”+关键词就能专门搜索标题
		文章内容约定，0段落=标题；1段落=url。url并不一定必须。
	*/
	u := "-" //当url为空时，以此为标志。
	if url != "" {
		u = url
	}
	section := c.TextSplit("《"+title+"》\n"+u+"\n"+text, split)
	for _, sec := range section {
		s = strings.TrimSpace(sec)
		if s == "" {
			continue
		}
		if r { //添加内容
			err = Con.Getartdb().Db.Put(JoinBytes([]byte(c.tbn+"-"), IntToBytes(id), []byte("-"), IntToBytes(i)), []byte(s), nil)
		} else {
			return
		}
		r = r && err == nil
		r = r && c.idx.Insert(id, i, sec) //添加内容段落索引
		i++
		Chekerr()
	}
	return
}

//******搜索*************************************
//idx.Search(...)该函数不能放进idx结构类。
//为了优化组合查询速度，搜索时会使用到content类。
//这样造成循环引用。故提出到该层来实现。
func (c *content) Search(keyword, p, caids string, order bool, count int) (asids []asid, lastkey string) {
	ks := strings.Split(keyword, " ")
	//获取字数最长的词，通常字数最长的就是数据量最少的词。以该词作为组合查询的遍历定位词。
	kw := c.getMaxLenKw(ks)
	kw = Sublen(kw, c.idx.keywordlen) //搜索词最大长度
	var ok bool
	iter := c.idx.Getiter(kw) //获取kw为前缀的查询索引游标。
	if p != "" {
		ok = iter.Seek([]byte(p)) //第二页开始可以定位。
	} else {
		ok = fixed[order](iter) //第一页定位。升序first，降序last。
	}
	succ := 0
	var e bool
	var key string
	var artid, secid int
	tasid := asid{}
	for ok {
		e = true
		key = string(iter.Key())
		//fmt.Println(key)
		artid, secid = c.getasid(key)
		e = e && c.rand(artid, caids)      //目录范围查询
		e = e && c.exsit(artid, secid, ks) //组合查询
		if !e {
			ok = move[order](iter)
			continue
		}
		if (tasid.artid == artid) && (tasid.secid == secid) {
			ok = move[order](iter)
			continue //排除重复。同一段落包含多个相同kw时，出现重复情况。
		}
		tasid.artid = artid
		tasid.secid = secid
		asids = append(asids, tasid)
		succ++
		if succ >= count {
			lastkey = key
			break
		}
		ok = move[order](iter) //游标移动。升序next，降序prev。
	}
	iter.Release()
	err = iter.Error()
	Chekerr()
	lastkey = key
	return
}

//在某个或多个目录下查找
//caids目录id集合
func (c *content) rand(artid int, caids string) (r bool) {
	if caids == "" {
		r = true
		return
	}
	ids := "|" + caids + "|"
	fid := CRAMs.cataRAM[artid-1].fid
	loop := 0
	for fid > 0 { //遍历到顶级目录
		if strings.Contains(ids, "|"+strconv.Itoa(fid)+"|") {
			r = true
			return
		} else {
			//防止用户输入的目录混乱。
			if fid < 0 || fid >= len(CRAMs.cataRAM) {
				return
			}
			fid = CRAMs.cataRAM[fid].fid
		}
		loop++
		if loop >= 108 { //防止用户输入的目录混乱导致死循环。
			return
		}
	}
	return
}

//组合查询
func (c *content) exsit(artid, secid int, ks []string) (find bool) {
	find = true
	if len(ks) < 2 {
		return
	}
	sec := c.GetOneSec(artid, secid)
	Chekerr()
	secstr := string(sec)
	for _, v := range ks { //如果在该段落内容里，所有的词组都存在，即是匹配。
		//Sublen(v, c.idx.keywordlen),只需前面7个字（7=索引长度keywordlen）匹配即可。
		find = find && strings.Contains(secstr, Sublen(v, c.idx.keywordlen))
	}
	return
}

//找出最大长度的词
func (c *content) getMaxLenKw(ks []string) (s string) {
	l := 0
	lv := 0
	for _, v := range ks {
		lv = len([]rune(v))
		if lv > l {
			s = v
			l = lv
		}
	}
	return
}

//byte的key中转换提取文章id，段落id
func (c *content) getasid(key string) (artid, secid int) {
	para := strings.Split(key, "-")
	artid = BytesToInt([]byte(para[2])) //文章id
	secid = BytesToInt([]byte(para[3])) //段落id
	return
}

//通过文章id和段落id，获取段落id的内容。
func (c *content) GetOneSec(artid, secid int) (sec []byte) {
	sec, err = Con.Getartdb().Db.Get(JoinBytes([]byte(c.tbn+"-"), IntToBytes(artid), []byte("-"), IntToBytes(secid)), nil)
	Chekerr()
	return
}

//获取搜索结果的节录内容
//在当前段落id至向后10个段落区间读取内容累加。直至内容长度达到最小长度minlentext。
func (c *content) GetMinLenText(artid, secid, minlentext int) (r string) {
	b := JoinBytes([]byte(c.tbn+"-"), IntToBytes(artid), []byte("-"), IntToBytes(secid))
	e := JoinBytes([]byte(c.tbn+"-"), IntToBytes(artid), []byte("-"), IntToBytes(secid+10)) //最多10句，不够则忽略。
	iter := Con.Getartdb().Db.NewIterator(&util.Range{Start: []byte(b), Limit: []byte(e)}, nil)
	var aid, value string
	var iaid int
	for iter.Next() {
		aid = strings.Split(string(iter.Key()), "-")[1]
		iaid = BytesToInt([]byte(aid))
		if iaid != artid { //已经是不同文章
			break
		}
		value = string(iter.Value())
		r += value
		if len([]rune(r)) >= minlentext {
			break
		}
	}
	iter.Release()
	err = iter.Error()
	Chekerr()
	return
}

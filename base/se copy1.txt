package base

import (
	"research/pubgo"
	"strings"

	"github.com/syndtr/goleveldb/leveldb/iterator"
)

//搜索结构体
type Se struct {
	//Con   *Connect
	idx   *idx
	fixed map[bool]func(iter iterator.Iterator) bool //起始位置。升序，first；降序，last
	move  map[bool]func(iter iterator.Iterator) bool //遍历顺序动作。升序，next；降序，prev
	order bool                                       //排序方式
}

func NewSe(order bool) *Se {
	fixed := make(map[bool]func(iter iterator.Iterator) bool, 2)
	fixed[true] = first
	fixed[false] = last

	move := make(map[bool]func(iter iterator.Iterator) bool, 2)
	move[true] = next
	move[false] = prev

	return &Se{
		//Con:   con,
		idx:   Newidx(),
		fixed: fixed,
		move:  move,
		order: order,
	}
}

//var fixed map[bool]func(iter iterator.Iterator) bool //起始位置。升序，first；降序，last
//var move map[bool]func(iter iterator.Iterator) bool  //遍历顺序动作。升序，next；降序，prev
//返回结果集。文章和段落的id
type Ids struct {
	artid int
	secid int
}

func newIds(artid, secid int) Ids {
	return Ids{artid: artid, secid: secid}
}

//用于第一次搜索时初始化开始key
func (s *Se) getfirst(pfx string) (inikey string) {
	iter := s.idx.Getiter(pfx) //Con.Getidxdb(pfx).Db.NewIterator(util.BytesPrefix([]byte(pfx)), nil)
	if s.fixed[s.order](iter) {
		inikey = string(iter.Key())
	}
	return
}

//搜索
func (s *Se) Search(keyword, p, rand string, count int) (ids []Ids, lastkey string) {
	var iters []iterator.Iterator
	ks := strings.Split(keyword, " ")
	for i := 1; i < len(ks); i++ {
		//iters = append(iters, Con.Getidxdb(ks[i]).Db.NewIterator(util.BytesPrefix([]byte(ks[i])), nil))
		iters = append(iters, s.idx.Getiter(ks[i]))
	}
	if len(strings.Split(p, "-")) == 1 { //p不是页码，而是页码的起始key
		p = s.getfirst(ks[0]) //第一次搜索没有初始定位key，需要获取
	}
	iter := s.idx.Getiter(ks[0]) // Con.Getidxdb(ks[0]).Db.NewIterator(nil, nil)
	ok := iter.Seek([]byte(p))
	if !ok {
		return
	}
	ok = s.fixed[s.order](iter)
	succ := 0
	var e bool
	var key string
	var artid, secid int
	var find, eof bool
	for ok {
		e = true
		key = string(iter.Key())
		if !strings.Contains(key, ks[0]) { //不在范围内。
			return
		}
		artid, secid = getids(key)
		find, eof = s.exsit(artid, secid, iters)
		if eof { //遍历完数据都没有找到。
			lastkey = ""
			return
		}
		e = e && find //组合查询
		if !e {
			continue
		}
		ids = append(ids, newIds(artid, secid))
		succ++
		if succ >= count {
			lastkey = key
			break
		}
		s.move[s.order](iter)
	}
	iter.Release()
	iter.Error()

	lastkey = key
	return
}

func (s *Se) exsit(iartid, isecid int, iters []iterator.Iterator) (find bool, eof bool) {
	var (
		f            bool
		artid, secid int
	)
	find = true
	eof = false
	f = false

	var key string
	for idx, i := range iters {
		if idx > 2 { //最多支持3个组合搜索
			break
		}
		find = find && s.fixed[s.order](i)
		if !find { //找不到
			break
		}
		f = s.move[s.order](i)
		for f {
			key = string(i.Key())
			artid, secid = getids(key)
			if artid == iartid && secid == isecid { //找到，同一文章，同一段落内
				find = true
				break
			}
			if s.order && artid < iartid && secid < isecid { //还未找到（升序的情况）
				f = s.move[s.order](i)
			}
			if !s.order && artid > iartid && secid > isecid { //还未找到（降序的情况）
				f = s.move[s.order](i)
			}
			if s.order && artid == iartid && secid > isecid { //不会再找到.同一文章，但是段落已经越过（升序的情况）
				//find = false
				return false, false
			}
			if !s.order && artid == iartid && secid < isecid { //不会再找到.同一文章，但是段落已经越过（降序的情况）
				//find = false
				return false, false
			}
			if s.order && artid > iartid { //不会再找到.已经不同文章，文章已经越过（升序的情况）
				//find = false
				return false, false
			}
			if !s.order && artid < iartid { //不会再找到.已经不同文章，文章已经越过（降序的情况）
				//find = false
				return false, false
			}
		} //循环结束都没有退出，即是遍历完数据都没有找到。
		eof = true
		return
	}
	return
}

//提取文章，段落id
func getids(key string) (artid, secid int) {
	para := strings.Split(key, "-")
	artid = pubgo.BytesToInt([]byte(para[2])) //文章id
	secid = pubgo.BytesToInt([]byte(para[3])) //段落id
	return
}

/*
func (a *Article) getfirst(pfx string, order bool) (find string) {
	iter := a.Con.Getidxdb(pfx).Db.NewIterator(util.BytesPrefix([]byte(pfx)), nil)
	if fixed[order](iter) {
		find = string(iter.Key())
	}
	return
}
*/
func first(iter iterator.Iterator) bool {
	return iter.First()
}
func last(iter iterator.Iterator) bool {
	return iter.Last()
}
func prev(iter iterator.Iterator) bool {
	return iter.Prev()
}
func next(iter iterator.Iterator) bool {
	return iter.Next()
}
